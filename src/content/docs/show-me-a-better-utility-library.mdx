---
title: Show Me A Better Utility Library
description: No seriously, I want to know...
---

Let me finish that headline with: “...that meets these criteria”.

But hold on. Before we talk “criteria”, let me answer your inevitable question of “Better than what?”. The answer is [**Radashi**](https://radashi-org.github.io/), the _soon-to-be_ best utility library for TypeScript fans who don't want to go full *Functional Programming*™️. In other words, you enjoy the Lodash way, which I would describe as _idiomatic JavaScript_, more or less. Just know that while Lodash is an inspiration, Radashi diverges quite a bit on philosophy.

#### “Wait, why is it only ‘soon to be’ the best?”

The truth is, Radashi is still early in its development, though it does build off of a dormant utility library with 100K+ weekly downloads and like 3 years of active development (more on that later). That said, we believe the “ethos of Radashi” (its design principles) will be what eventually makes it the best utility library for non-FP TypeScript'ers. Especially once you understand the vision explained in this post, then perhaps some of you will start helping us fill in Radashi's _missing parts_.

Before I go any further, I have to tell you that, in my opinion, the best thing about Radashi is how easy it is to “make it yours”. This hassle-free customizability is sure to be a game changer for achieving “the perfect imperative TypeScript utility library” (which any seasoned developer knows is often times **project-specific**). But I'll get into the customizability part a bit later in this post. If you must know this very second, [read this](/your-own-radashi) (or maybe just keep reading this post instead)!

#### “Okay, so how's it better than Lodash?”

First off, you can't just say that one library is _better_ than another. As any seasoned developer knows, it's all about the tradeoffs. While I have admiration for Lodash and the masterpiece it once was, and while I could certainly wait for Lodash 5, I recently discovered another utility library called _Radash_ (which _Radashi_ is based on). Radash has a loose philosophy, one that is not comprehensively described in any one place, but if you read its introduction and contributing guide, you'd likely be able to piece together a good chunk of **Radashi's ethos**, a document written by me that lists the design principles to be followed when reviewing proposals and making decisions. Radashi has a lot to thank Radash for and is honored to carry its vision forward in a respectfully **more sustainable** and **more principled** way.

- Strengths

  - Modern

    - Use modern ESM syntax and TypeScript
    - Tree-shakeable
      - First and foremost, we all know tree-shaking is a must these days if you want to keep your startup performance slick. Radashi has `sideEffects: false` in its `package.json` file, so any exports you don't use will be tree-shaken away.
    - Use Biome for code formatting & linting
    - Use Vitest for testing

  - Minimal

    - Banish imports of internal modules (i.e. functions that **you, the user** cannot import from Radashi). Lodash prefixes these “internal modules” with an underscore. But this can make forking Lodash a pain in the ass.
    - Easy to copy-paste. Every function in Radashi has its own module, and these modules only ever import from `radashi`. This means you can go to [our Github page](https://github.com/radashi-org/radashi), wait for it to load, press the `t` key, type "all", press Enter to visit the source file, copy its code directly into your project (without any changes), and you're ready to make changes and use them. Just the fact that you can do this so easily makes Radashi easier to adapt your project's needs.
    - Keep code size low without sacrificing performance
    - Avoid syntax sugar unless it meaningfully improves “read-ability” or reduces “bug rate” or “tech debt”
    - Avoid adding functions that only cover uncommon use cases. Likewise, avoid extending functions with options/parameters that only cover an uncommon use case.
    - Avoid polymorphism in most cases.
      - Polymorphism is a great way to bloat your utility library. While I totally understand the desire to keep the number of function names to a minimum (naming is hard you know), nobody wants to use 30% of a function yet pay for 100% of its bundle size. The more that happens, the more your codebase becomes bloated by unused library code.
      - Polymorphism is also not great for code readability. The more overloaded a function is, the less sure I am of what it's doing at a glance. I now have to consider the input types to determine the behavior.
      - TypeScript's type system, while powerful, can sometimes struggle with highly polymorphic functions, leading to complex type definitions that are hard to understand and maintain.
      - Polymorphic functions often require more runtime type checking, which can impact performance, especially in hot code paths.
      - Instead of relying on polymorphism, we prefer to create separate, well-named functions for different use cases. This approach leads to clearer, more predictable code and better tree-shaking opportunities. That said, there's a time and place for polymorphism, so we don't reject it entirely.

  - Robust

    - Changes are automatically linted before being merged to `main`
    - Browser compatibility checks are in place. Check out compatibility on our [Browser Support](/browser-support) page.

  - Top-notch static types
    - We strive for 100% correct types and we're well-practiced on the intricacies of complex TypeScript generics. There's little more frustrating than a library with incorrect or incomplete types.
  - Make it your own
    - I've developed a template repository and a CLI tool that make developing your own customized Radashi package a breeze. The template repository is [found here](https://github.com/radashi-org/radashi-template). Its CLI helper is [found here](https://github.com/radashi-org/radashi-helper).
    - **Overriding functions** is easy. **Adding your own functions** is super fast. The repository is setup and ready to go, so there's no barrier to getting started. Just clone the template and run `pnpm install && pnpm radashi help` to get acquainted. **Easily contribute your improvements** back to Radashi upstream. **Publishing your own Radashi to NPM** is hassle-free.
    - You can read [this guide](/your-own-radashi) if you prefer tutorials on the web instead of in the terminal.
  - Easy to contribute
    - If you prefer to clone Radashi and manage your fork directly, that's also possible, of course.
    - Radashi has its own scripts to make adding new functions easy. After cloning Radashi, run `pnpm add-function <group-name>/<function-name>` to scaffold the files for a new function. More info in the [contributing guide](/contributing).
  - Automatic beta releases
    - Every day at 05:00 AM UTC (01:00 AM EST), a beta version is published if there are any publishable changes. This means when a PR is merged, it can be installed through the `radashi@beta` version the next day.
  - Preview releases
    - When you submit a PR, you can comment `/preview` to release a preview version of the PR to NPM and install it with `pnpm install radashi@pr123`.
  - High-quality documentation site
  - Active maintainers
    - Currently, I'm the most active maintainer of Radashi, but others are already helping to review PRs and contributing their own PRs.
    - My current goal is to grow the Radashi core team as much as possible. My end goal is to have Radashi be a community effort. For now, that means the barrier to joining the core team is practically non-existent, though you do need to contribute (be it by reviewing PRs, contributing your own PRs, or offering your perspective in design discussions) at least a couple times in a 3 month period.
    - I will gladly give publishing privilege to anyone who demonstrates passion and expertise over their 2 months on the core team. These privileged few are the “stewards of Radashi” that will keep Radashi evolving and responsive to contributors.
    - If you'd like to join the effort, [reach out here](https://github.com/orgs/radashi-org/discussions/4) or DM me on X at [@retropragma](https://x.com/retropragma).

- Parity

  - Use cases
    - We don't plan to cover all of the use cases that Lodash does, but we definitely want to cover the most popular ones. This can be roughly gauged by looking at the weekly download count of each `lodash.*` NPM package.
    - We have [a little page](/lodash-parity) that lists the Lodash functions in order of weekly downloads. It also tracks which functions of Lodash have been implemented in Radashi and how Radashi's functions may differ.
  - Full test coverage
    - Radashi has it.
  - Benchmarks, perf regression detection
    - Radashi has it.
    - We would love to add Lodash comparisons in the future. PR welcome!

- Weaknesses

  - Not battle-tested? True, but we have full test coverage and we'll be very responsive to bug
    reports. That said, growing the core team is critical in scaling our responsiveness.
  - Not enough stars? True, but you (the reader) can help on that front. Goto [our Github page](https://github.com/radashi-org/radashi) and give us a star to help others find us.
  - Something else? Share your ideas and critique in [our Github discussions](https://github.com/radashi-org/radashi/discussions).

- Give us a try
  - We have a StackBlitz for you to easily test drive Radashi. [Click here]() to try.
  - TODO(claude): write a code block containing `pnpm install radashi` command
- Funding
  - Currently, Radashi has no sponsors and it doesn't yet have an OpenCollective page. If you'd like to sponsor or donate to the Radashi effort, [let us know](https://github.com/orgs/radashi-org/discussions/129).
